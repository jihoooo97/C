#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main()
{

    int a = 10;
    int* p = &a;


    printf("포인터변수 p의 크기: %d\n", sizeof(p));

    // 예상: 8, 결과: 8 

    // 64비트의 컴파일러에선 포인터 변수의 크기는 8바이트이다. 



    printf("%d\n", a);	// 예상: 10, 결과: 10, 이유: a에 저장된 값이 10이기 때문 
    printf("%d\n", *p); // 예상: 10, 결과: 10, 이유: *p는 a의 주소에ㅔ 있는 값을 가르키는 포인터이기 때문 


    printf("%p\n", a);  // 예상: a의 주소에 있는 값을 가르키는 16진수 값, 결과: 000000000000000A
                        // 이유: %p는 포인터 주소를 16진수로 가르키는 값이기 때문 
    printf("%p\n", *p); // 예상: a의 주소에 있는 값을  가르키는 16진수 값, 결과: 000000000000000A
                        // 이유: *p는 a의 주소를 가르키는 포인터이므로 위의 코드와 결과가 같다 
    printf("%p\n", p);  // 예상: a의 주소를 가르키는 16진수 값, 결과: 000000000062FE14



    printf("%d\n", (*p)++); // 예상: 10, 결과: 10
                            // 이유: 먼저 *p의 값을 출력하고 값이 증가되기 떄문(++는 후위 연산) 
    printf("%d\n", *p); // 예상: 11, 결과: 11
                        // 이유: 위에서 a의 값이 1 증가되어 11이 됐기 때문 
    printf("%p\n", p); // 예상: a의 주소를 가르키는 16진수 값, 결과: 000000000062FE14


    printf("%d\n", *p++); // 예상: 11, 결과: 11
                          // ++은 후위 연산자이므로 코드가 끝난뒤에 증가되기 때문에 
                          // p에 있는 값 a는 그대로 출력 
    printf("%d\n", *p); // 예상: ?, 결과: 6487576
                        // 이유: 위에서 p의 주소를 4만큼 이동시켰기에 더미값이 출력됨 
    printf("%p\n", p); // 예상: a의 주소+4바이트를 가르키는 16진수 값, 결과: 000000000062FE18


    return 0;

}